# TODO: AQEIBridge Workflow for Causal Stability Conjecture

## Project Goal Recap
Build an iterative hybrid workflow:
- **Mathematica**: Heuristic search / numerical exploration of perturbations (candidate generation, counterexample hunting).
- **Python**: Orchestration, analysis of candidates, emission of Lean lemma skeletons / conjectures / proof stubs.
- **Lean 4**: Formal definitions, statements, and (eventually) proofs of stability under AQEI-admissible perturbations.

Target conjecture:
> Metric perturbations generated by AQEI-admissible stress–energy tensors produce a path-connected family of causal futures (no change in global causal homotopy class) in small neighborhoods.

Current status: Toy 1+1D pipeline runs end-to-end but uses ad-hoc/synthetic AQEI proxies and a crude causal observable (∫ h along null-ish rays). No formal statement of the conjecture yet in Lean; files may be placeholders or minimal.

## Phase 1: Stabilize & Document Current Toy Pipeline (High Priority, Next 1–2 weeks)
- [ ] Create `docs/` directory and move relevant documentation here (start with this TODO.md).
- [ ] Add `docs/architecture.md`: Diagram / explanation of the 4-stage pipeline (Mathematica → candidates → Python analysis → Lean skeletons → typecheck). Include sample Mathematica code for Gaussian wavepacket generation, e.g.:
  ```mathematica
  gaussianPacket[t_, x_, σ_, k_] := Exp[-((t - x)^2)/(2 σ^2)] * Cos[k (t - x)];
  Export["candidates.json", Table[gaussianPacket[t, x, 0.1, 2], {t, 0, 1, 0.01}, {x, 0, 1, 0.01}]];
  ```
  And Python code for analysis, e.g.:
  ```python
  import json
  with open('candidates.json') as f:
      data = json.load(f)
  max_delta = max([integrate_along_ray(d) for d in data])  # Placeholder for causal observable
  ```
- [ ] Add `docs/conjecture.md`: Write the precise mathematical statement of the conjecture, including LaTeX math for definitions (e.g., AQEI-admissible tensors satisfying \( T^{ab} k_a k_b \geq 0 \) for null \( k \), averaged quantum energy inequalities, metric perturbation \( h_{ab} \) via linearized Einstein equations \( \delta G_{ab} = 8\pi \delta T_{ab} \), causal future \( J^+(p) \), path-connectedness in the space of causal futures under small perturbations, and invariance of global causal homotopy class). Include sample Lean code skeleton:
  ```lean
  import Mathlib.Topology.Basic
  def CausalFuture (M : Type*) [LorentzianManifold M] (p : M) : Set M := {q | ∃ γ : CausalCurve p q}
  conjecture CausalStability : ∀ (ε > 0) (T : StressEnergyTensor), AQEIAdmissible T → SmallPerturbation T ε →
    PathConnected (FamilyOfCausalFutures T) ∧ HomotopyClassInvariant (GlobalCausalStructure T)
  ```
- [ ] Add `docs/toy-model.md`: Document assumptions/limitations of the 1+1D Gaussian-wavepacket ansatz, Fourier Green multiplier, null-ray proxy Δ (e.g., \( \Delta = \int h \, d\lambda \) along approximate null rays). Include math derivations, e.g., linearized metric in 1+1D: \( ds^2 = -dt^2 + dx^2 + h(t,x) (dt^2 + dx^2) \), and sample Python code for null-ray integration:
  ```python
  import numpy as np
  from scipy.integrate import simps
  def integrate_along_ray(h_grid, ray_path):
      # ray_path: list of (t,x) points along null ray (t+x=const)
      values = [h_grid[t_idx, x_idx] for t_idx, x_idx in ray_path]
      return simps(values, dx=0.01)  # Assuming grid spacing 0.01
  ```
- [ ] Expand README quick-start with common failure modes and how to debug (e.g., WolframScript path, grid size effects, numerical stability of FFT).
- [ ] Add logging / result persistence in `orchestrator.py` (save all runs with timestamps, parameters, best scores, active constraints). Include example Python logging code:
  ```python
  import logging
  logging.basicConfig(filename='runs.log', level=logging.INFO)
  logging.info(f"Run at {timestamp}: max_delta={max_delta}, constraints={constraints}")
  ```
- [ ] Write local tests that assert end-to-end runs without crash (even if results are nonsense). Add a `tests/` directory with `test_pipeline.py` using unittest or pytest, e.g.:
  ```python
  import unittest
  from orchestrator import run_pipeline
  class TestPipeline(unittest.TestCase):
      def test_end_to_end(self):
          result = run_pipeline(test_mode=True)
          self.assertIsNotNone(result)
          self.assertGreater(len(result), 0)
  if __name__ == '__main__':
      unittest.main()
  ```
  And a bash script `run_tests.sh` to execute them locally.

## Phase 2: Formalize Core Concepts in Lean (High Priority)
- [ ] Formalize basic GR/spacetime structures in `Spacetime.lean` (Lorentzian manifolds, causal curves, future sets J⁺(p), small neighborhoods). Include math: e.g., a curve γ is causal if \( g(\dot{\gamma}, \dot{\gamma}) \leq 0 \).
- [ ] Complete `StressEnergy.lean`: Define finite-dim stress-energy tensors, mappings to metric perturbations (linearized Einstein). Include sample Lean code:
  ```lean
  structure StressEnergyTensor where
    components : ℝ^{4×4}
    aqei_admissible : ∀ k : NullVector, components k k ≥ 0
  def MetricPerturbation (T : StressEnergyTensor) : MetricTensor := linearized_einstein T
  ```
- [ ] Complete / expand `AQEI_Cone.lean`: Formalize AQEI-admissible set as intersection of half-spaces from linear functionals (sampling-based cone), prove convexity / cone properties. Use Mathlib for convex sets.
- [ ] In `CausalStability.lean` (or new `Conjecture.lean`): State the conjecture formally (e.g., as ∀ small admissible T, the family of perturbed causal futures is path-connected with fixed homotopy class). Include full math statement in LaTeX.
- [ ] Add basic lemmas: small perturbations preserve local causality, continuity of J⁺ under metric perturbations (use Mathlib topology / continuity).
- [ ] Create `GeneratedCandidates.lean` stubs for Python-emitted results (e.g., conjectured inequalities from numerical max Δ).

## Phase 3: Improve Heuristics & Bridge (Medium-High Priority)
- [ ] Replace synthetic/ad-hoc AQEI inequalities in `search.wl` with more faithful proxies (derive from actual AQEI sampling functionals in the manuscript; add non-linear constraints if needed via other optimizers). Include sample Mathematica code for constraints:
  ```mathematica
  constraints = {Integrate[T[t, x] φ[t, x], {t, -∞, ∞}, {x, -∞, ∞}] >= 0} /. φ -> SamplingFunctional;
  NMaximize[{Δ, constraints}, params]
  ```
- [ ] Improve causal observable in Mathematica: Beyond ∫ h dλ along rays — add ray tracing for actual null geodesics in perturbed metric, check for focusing/defocusing or horizon formation proxies. Include math: null geodesic equation \( \ddot{x}^\mu + \Gamma^\mu_{\alpha\beta} \dot{x}^\alpha \dot{x}^\beta = 0 \).
- [ ] Add multi-ray / multi-point analysis: Check path-connectedness proxy (e.g., whether families of J⁺ overlap continuously).
- [ ] Explore higher-dimensional toy models (start with 2+1D cylindrical or toroidal grid).
- [ ] Enhance `analyze_candidates.py`: Translate high-score candidates into Lean-usable statements (e.g., conjectured bounds on Δ, potential counterexample shapes). Include Python code for emission:
  ```python
  with open('GeneratedCandidates.lean', 'w') as f:
      f.write(f"conjecture MaxDeltaBound : Δ ≤ {bound} := sorry\n")
  ```
- [ ] Add Python support for parameter sweeps (grid search over N basis funcs, σ, constraint tightness) and Pareto analysis (tradeoff between Δ and constraint violation). Use numpy for sweeps.

## Phase 4: Toward Proof / Disproof (Medium-Long Term)
- [ ] Run large-scale searches: Look for candidates that produce large Δ or qualitative causal changes despite constraints → if none found in broad regimes → evidence for conjecture.
- [ ] If candidates show bounded Δ → formalize bound in Lean as lemma, e.g., with math proof sketch.
- [ ] Transition toy → realistic: Perturb Minkowski, then simple curved backgrounds (e.g., Schwarzschild exterior).
- [ ] Incorporate linearized Einstein solver (or post-Newtonian) in Mathematica/Python loop. Include sample Mathematica code:
  ```mathematica
  h = InverseFourierTransform[G[k] T[k], k, x];  (* Green function multiplier *)
  ```
- [ ] Attempt Lean proofs of special cases: e.g., vacuum perturbations, weak-field limits, 1+1D toy fully formalized.
- [ ] If counterexample-like behavior appears → refine conjecture (local vs global, size of neighborhood).

## General / Ongoing
- [ ] Add local test scripts: e.g., `run_tests.sh` to execute `test_pipeline.py`, Lean typecheck (`lake build`), and simple Mathematica search (`wolframscript -file search.wl`).
- [ ] Integrate / depend on Mathlib more deeply (topology, analysis, differential geometry).
- [ ] Review / incorporate ideas from history (see `history/history.md`).
- [ ] License the repo (e.g., MIT ).
- [ ] Add visualization outputs from Mathematica (plots of h, rays, constraints). Include sample code:
  ```mathematica
  ContourPlot[h[t, x], {t, 0, 1}, {x, 0, 1}, PlotLegends -> Automatic]
  ```

Prioritize Phase 1 and 2 first — without a precise Lean statement and better documentation, iteration is harder.